# Effective Software Testing with Lambda Forge

<!DOCTYPE html>
<html lang="en">
	<head>
		<script src="https://cdn.tailwindcss.com"></script>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />

    	<title>Chat App</title>
    	<meta name="description" content="Generated by create next app" />
    	<link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16" />
    	<script
    		src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"
    		crossorigin=""
    		nomodule=""
    	></script>
    </head>
    <body class="__className_aaf875">
    	<main class="bg-gray-100 mb-12 pb-6">
    		<div class="flex gap-4 justify-around px-2 pt-6">

    			<div class="bg-white px-3 py-5 w-[48%] flex flex-col shadow-xl">
    				<div class="flex gap-2 border-b pb-3 items-center justify-between">
    					<div class="flex gap-3">
    						<div class="bg-orange-500 w-10 h-10 rounded-full"></div>
    						<div class="">
    							<p class="font-bold" id="ïd1"></p>
    						</div>
    					</div>
    				</div>

    				<ul
    					id="messages1"
    					class="w-full h-[450px] max-h-[450px] overflow-y-auto px-1"
    				>
    				</ul>

    				<div
    					class="items-center w-full flex gap-2 mt-6 text-[15px] justify-center"
    				>
    					<input
    						id="messageInput1"
    						placeholder="Type your text..."
    						class="p-2 h-7 flex-1 border border-gray-300 rounded-xl bg-gray-100"
    					/><button
    						id="sendMessage1"
    						sendMessage()
    						class="rounded-md h-7 w-7 justify-center bg-blue-500 text-white font-medium items-center flex gap-2"
    					>
    						<svg
    							xmlns="http://www.w3.org/2000/svg"
    							viewBox="0 0 24 24"
    							fill="currentColor"
    							aria-hidden="true"
    							data-slot="icon"
    							class="w-[18px] h-[18px]"
    						>
    							<path
    								d="M3.478 2.404a.75.75 0 0 0-.926.941l2.432 7.905H13.5a.75.75 0 0 1 0 1.5H4.984l-2.432 7.905a.75.75 0 0 0 .926.94 60.519 60.519 0 0 0 18.445-8.986.75.75 0 0 0 0-1.218A60.517 60.517 0 0 0 3.478 2.404Z"
    							></path>
    						</svg>
    					</button>
    				</div>
    			</div>

    			<!--  CHAT 2 -->

    			<div class="bg-white px-3 py-5 w-[48%] flex flex-col shadow-xl">
    				<div class="flex gap-2 border-b pb-3 items-center justify-between">
    					<div class="flex gap-3">
    						<div class="bg-orange-500 w-10 h-10 rounded-full"></div>
    						<div class="">
    							<p class="font-bold" id="id2"></p>
    						</div>
    					</div>
    				</div>

    				<ul id="messages2" class="w-full h-[450px] max-h-[450px] overflow-y-auto px-1">
    				</ul>
    				<div
    					class="items-center w-full flex gap-2 mt-6 text-[15px] justify-center"
    				>
    					<input
    						id="messageInput2"
    						placeholder="Type your text..."
    						class="p-2 h-7 flex-1 border border-gray-300 rounded-xl bg-gray-100"
    					/><button
    						id="sendMessage2"
    						sendMessage()
    						class="rounded-md h-7 w-7 justify-center bg-blue-500 text-white font-medium items-center flex gap-2"
    					>
    						<svg
    							xmlns="http://www.w3.org/2000/svg"
    							viewBox="0 0 24 24"
    							fill="currentColor"
    							aria-hidden="true"
    							data-slot="icon"
    							class="w-[18px] h-[18px]"
    						>
    							<path
    								d="M3.478 2.404a.75.75 0 0 0-.926.941l2.432 7.905H13.5a.75.75 0 0 1 0 1.5H4.984l-2.432 7.905a.75.75 0 0 0 .926.94 60.519 60.519 0 0 0 18.445-8.986.75.75 0 0 0 0-1.218A60.517 60.517 0 0 0 3.478 2.404Z"
    							></path>
    						</svg>
    					</button>
    				</div>

    		</div>
    	</main>
    	<script>const BASE_URL = 'wss://2clnav84i7.execute-api.us-east-2.amazonaws.com/dev/';

    		// SOCKET 1
    		const sendButton1 = document.getElementById('sendMessage1');
    		const idName1 = document.getElementById('ïd1');
    		sendButton1.addEventListener('click', sendMessage1);
    		let id1;

    		const socket1 = new WebSocket(BASE_URL);

    		socket1.onopen = function (event) {
    			console.log('Conexão estabelecida.');
    		};

    		socket1.onmessage = function (event) {
    			console.log('Mensagem recebida:', event.data);
    			const data = JSON.parse(event.data);
    			if (data.connection_id) {
    				id1 = data.connection_id;
    				idName1.innerText = id1;
    				return;
    			}

    			const messagesDiv = document.querySelector('#messages1');

    			messageReader(id1, data.sender_id, messagesDiv, data.message);
    		};

    		socket1.onerror = function (error) {
    			console.error('Erro na conexão WebSocket:', error);
    		};

    		socket1.onclose = function (event) {
    			if (event.wasClean) {
    				console.log('Conexão fechada corretamente.');
    			} else {
    				console.error('Conexão fechada com erro.');
    			}
    			console.log('Código do fechamento:', event.code, 'Motivo:', event.reason);
    		};

    		function sendMessage1() {
    			const messageInput = document.getElementById('messageInput1');
    			const messageText = messageInput.value;
    			const message = {
    				action: 'sendMessage',
    				message: messageText,
    				recipient_id: id2,
    			};

    			const stringMessage = JSON.stringify(message);
    			console.log(stringMessage);
    			if (messageText.trim() !== '') {
    				console.log(stringMessage);
    				socket1.send(stringMessage);
    				messageInput.value = '';
    			} else {
    				alert('Write a message');
    			}
    		}
    		document.getElementById('messageInput1').addEventListener('keypress', function (event) {
    			if (event.key === 'Enter') {
    				event.preventDefault();
    				sendMessage1();
    			}
    		});
    		const messageReader = (myId, senderId, selector, text) => {
    			console.log(myId, senderId);
    			const newListItem = document.createElement('li');
    			newListItem.classList.add('mb-2', 'flex', 'gap-2', 'false');
    			if (myId == senderId) {
    				newListItem.classList.add('flex-row-reverse');
    				newListItem.innerHTML = `
    				<div class="bg-blue-400 hidden w-9 h-9 rounded-full"></div>
    									<div
    										class="self-end max-w-[93%] mt-1 p-3 rounded-b-2xl rounded-tl-2xl bg-blue-300/30"
    									>
    										<p class="text-[15px]">
    											${text}
    										</p>
    										<p class="text-end mt-1 text-[12px] font-medium text-gray-500">
    											24/05/06
    										</p>
    									</div>`;
    			} else {
    				newListItem.innerHTML = `
    				<div class="bg-orange-400 hidden w-9 h-9 rounded-full"></div>
    				<div
    				class="self-end max-w-[93%] mt-1 p-3 rounded-b-2xl rounded-tr-2xl bg-orange-300/30"
    				>
    				<p class="text-[15px]">
    				${text}
    				</p>
    				<p class="text-end mt-1 text-[12px] font-medium text-gray-500">
    				24/05/06
    				</p>
    				</div>`;
    			}
    			selector.appendChild(newListItem);
    		};

    		// SOCKET 2
    		const sendButton2 = document.getElementById('sendMessage2');
    		sendButton2.addEventListener('click', sendMessage2);
    		const idName2 = document.getElementById('id2');

    		const socket2 = new WebSocket(BASE_URL);
    		let id2;

    		socket2.onopen = function (event) {
    			console.log('Conexão estabelecida.');
    		};

    		socket2.onmessage = function (event) {
    			console.log('Mensagem recebida:', event.data);
    			const data = JSON.parse(event.data);
    			console.log(data);
    			if (data.connection_id) {
    				id2 = data.connection_id;
    				idName2.innerText = id2;
    				return;
    			}

    			const messagesDiv = document.querySelector('#messages2');

    			messageReader(id2, data.sender_id, messagesDiv, data.message);
    		};

    		socket2.onerror = function (error) {
    			console.error('Erro na conexão WebSocket:', error);
    		};

    		socket2.onclose = function (event) {
    			if (event.wasClean) {
    				console.log('Conexão fechada corretamente.');
    			} else {
    				console.error('Conexão fechada com erro.');
    			}
    			console.log('Código do fechamento:', event.code, 'Motivo:', event.reason);
    		};

    		function sendMessage2() {
    			const messageInput = document.getElementById('messageInput2');
    			const messageText = messageInput.value;
    			const message = {
    				action: 'sendMessage',
    				message: messageText,
    				recipient_id: id1,
    			};
    			const stringMessage = JSON.stringify(message);
    			if (messageText.trim() !== '') {
    				console.log(stringMessage);
    				socket2.send(stringMessage);
    				messageInput.value = '';
    			} else {
    				alert('Write a message');
    			}
    		}
    		document.getElementById('messageInput2').addEventListener('keypress', function (event) {
    			if (event.key === 'Enter') {
    				event.preventDefault();
    				sendMessage2();
    			}
    		});
    		</script>

    </body>

</html>

<!-- # Developing a Serverless CRUD App Using DynamoDB

In this section, we will develop a straightforward CRUD application designed to capture and manage user-defined names and ages, each uniquely identified by a UUID. This approach not only simplifies the demonstration of the architecture's capabilities but also emphasizes the practical application of these technologies in a user-centric scenario.

<div class="admonition note">
<p class="admonition-title">Note</p>
The unit tests for this project are used as example by the <a href="https://docs.lambda-forge.com/articles/page3" target="_blank">Mocking AWS Resources for Unit Testing</a> article. If you're interested in learning how to effectively mock DynamoDB for testing in your own projects, it's a highly recommended read.
</div>

## Configuring DynamoDB Tables for Each Deployment Stage

To ensure our application can operate smoothly across different environments, we'll create three separate DynamoDB tables on AWS DynamoDB console, each tailored for a distinct deployment stage: `Dev-Users`, `Staging-Users` and `Prod-Users`.

Having acquired the ARNs for each stage-specific table, our next step involves integrating these ARNs into the `cdk.json` file.

```json title="cdk.json" linenums="51" hl_lines="5 12 19"
    "dev": {
      "base_url": "https://api.lambda-forge.com/dev",
      "arns": {
        "urls_table": "$DEV-URLS-TABLE-ARN",
        "users_table": "$DEV-USERS-TABLE-ARN"
      }
    },
    "staging": {
      "base_url": "https://api.lambda-forge.com/staging",
      "arns": {
        "urls_table": "$STAGING-URLS-TABLE-ARN",
        "users_table": "$STAGING-USERS-TABLE-ARN"
      }
    },
    "prod": {
      "base_url": "https://api.lambda-forge.com",
      "arns": {
        "urls_table": "$PROD-URLS-TABLE-ARN",
        "users_table": "$PROD-USERS-TABLE-ARN"
      }
    }
```

## Implementing the Create Functionality

Next, we'll focus on constructing the "Create" functionality of our CRUD application. This feature is dedicated to inputting names and their corresponding ages into our DynamoDB tables. To initiate the creation of a Lambda function tailored for this operation, run the following command in the Forge CLI:

```

forge function create_user --method "POST" --description "Create a user with name and age on Dynamo DB" --belongs-to users --public

```

This command signals to Forge the need to generate a new Lambda function named create_user, which will handle POST requests. By applying the `--belongs-to` flag, we guide Forge to organize this function within the `users` directory, emphasizing its role as part of a suite of user-related functionalities.

```
functions
└── users
    ├── create_user
    │   ├── __init__.py
    │   ├── config.py
    │   ├── integration.py
    │   ├── main.py
    │   └── unit.py
    └── utils
        └── __init__.py
```

- `users/` This directory acts as the container for all Lambda functions related to users operations, organizing them under a common theme.
- `create_user/` This subdirectory is dedicated to the function for creating users, equipped with all necessary files for its execution, configuration, and testing.
- `utils/` A utility directory for shared functions or helpers that support the operations within the users functions, enhancing code reuse and maintainability.

### Core Logic

The Create User endpoint serves as the gateway for adding new users to our system. It processes incoming data from the request body, assigns a unique UUID to each user, and then stores this information in DynamoDB.
Now, let's delve into the details of the function implementation.

```python title="functions/users/create_user/main.py"
import json
import uuid
from dataclasses import dataclass
import os
import boto3


@dataclass
class Input:
    name: str
    age: int


@dataclass
class Output:
    id: str


def lambda_handler(event, context):
    # Retrieve the DynamoDB table name from environment variables.
    USERS_TABLE = os.environ.get("USERS_TABLE")

    # Initialize a DynamoDB resource.
    dynamodb = boto3.resource("dynamodb")

    # Reference the DynamoDB table.
    users_table = dynamodb.Table(USERS_TABLE)

    # Parse the request body to get user data.
    body = json.loads(event["body"])

    # Generate a unique ID for the new user.
    user_id = str(uuid.uuid4())

    # Insert the new user into the DynamoDB table.
    users_table.put_item(Item={"PK": user_id, "name": body["name"], "age": body["age"]})

    # Return a successful response with the newly created user ID.
    return {"statusCode": 200, "body": json.dumps({"user_id": user_id})}
```

### Configuration Class

Let's develop a configuration class to streamline the lambda function's access to necessary resources. This class will centralize the management of environment variables and resource configurations, thereby enhancing code maintainability and readability. It ensures that all external resources such as DynamoDB tables are easily configurable and securely accessed within the lambda function.

```python title="functions/users/create_user/config.py" hl_lines="12-14 19"
from infra.services import Services


class CreateUserConfig:
    def __init__(self, services: Services) -> None:

        function = services.aws_lambda.create_function(
            name="CreateUser",
            path="./functions/users",
            description="Create a user with name and age on Dynamo DB",
            directory="create_user",
            environment={
                "USERS_TABLE_NAME": services.dynamo_db.users_table.table_name,
            },
        )

        services.api_gateway.create_endpoint("POST", "/users", function, public=True)

        services.dynamo_db.users_table.grant_write_data(function)
```

## Implementing the Read Functionality

We're now set to construct the read feature, enabling the retrieval of user details using their ID.

To facilitate this, we'll utilize the following command:

```
forge function get_user --method "GET" --description "Retrieve user information by ID" --belongs-to users --endpoint "/users/{user_id}" --public
```

The `--endpoint "/users/{user_id}"` parameter sets up a specific URL path for accessing this function. This path includes a dynamic segment {user_id} that gets replaced by the actual ID of the user we're trying to retrieve information about when the function is called.

By running this command, we add a new layer to our application that specifically handles fetching user details in an organized, accessible manner.

```
functions
└── users
    ├── create_user
    │   ├── __init__.py
    │   ├── config.py
    │   ├── integration.py
    │   ├── main.py
    │   └── unit.py
    ├── get_user
    │   ├── __init__.py
    │   ├── config.py
    │   ├── integration.py
    │   ├── main.py
    │   └── unit.py
    └── utils
        └── __init__.py
```

### Core Logic

This segment of our application demonstrates the retrieval of user information from a DynamoDB table through an AWS Lambda function. It highlights how to parse API gateway events, interact with DynamoDB, and structure responses for efficient data delivery.

```python title="functions/users/get_user/main.py"
import json
import os
import boto3
from dataclasses import dataclass

@dataclass
class Path:
    user_id: str

@dataclass
class Input:
    pass

@dataclass
class Output:
    name: str
    age: int

def lambda_handler(event, context):
    # Retrieve the name of the DynamoDB table from environment variables.
    USERS_TABLE_NAME = os.environ.get("USERS_TABLE_NAME")

    # Initialize a DynamoDB resource using boto3.
    dynamodb = boto3.resource("dynamodb")

    # Reference the specific DynamoDB table by name.
    users_table = dynamodb.Table(USERS_TABLE_NAME)

    # Extract the user ID from the pathParameters provided in the event object.
    user_id = event["pathParameters"].get("user_id")

    # Retrieve the user item from the DynamoDB table using the extracted ID.
    user = users_table.get_item(Key={"PK": user_id}).get("Item")

    # Reformat the user item into the desired output structure.
    user = {"name": user["name"], "age": user["age"]}

    # Return the user data with a 200 status code, ensuring the body is properly JSON-encoded.
    return {"statusCode": 200, "body": json.dumps(user, default=str)}
```

### Configuration Class

The config class below outlines the configuration necessary for establishing the GetUser function within AWS, illustrating the seamless integration of AWS Lambda and API Gateway to expose a user data retrieval endpoint.

```python title="functions/users/get_user/config.py"
from infra.services import Services


class GetUserConfig:
    def __init__(self, services: Services) -> None:

        function = services.aws_lambda.create_function(
            name="GetUser",
            path="./functions/users",
            description="Retrieve user information by ID",
            directory="get_user",
            environment={
                "USERS_TABLE_NAME": services.dynamo_db.users_table.table_name,
            },
        )

        services.api_gateway.create_endpoint("GET", "/users/{user_id}", function, public=True)

        services.dynamo_db.users_table.grant_read_data(function)
```

## Implementing the Update Functionality

Let's utilize Forge once again to swiftly establish a tailored structure, setting the stage for our Update User functionality.

```
forge function update_user --method "PUT" --description "Update an user by ID" --belongs-to users --endpoint "/users/{user_id}" --public
```

As expected, after using the forge command to generate the `update_user` function, a predefined directory structure is created.

```
functions
└── users
    ├── create_user
    │   ├── __init__.py
    │   ├── config.py
    │   ├── integration.py
    │   ├── main.py
    │   └── unit.py
    ├── get_user
    │   ├── __init__.py
    │   ├── config.py
    │   ├── integration.py
    │   ├── main.py
    │   └── unit.py
    ├── update_user
    │   ├── __init__.py
    │   ├── config.py
    │   ├── integration.py
    │   ├── main.py
    │   └── unit.py
    └── utils
        └── __init__.py
```

### Core Logic

Below is the implementation for updating a user, allowing changes to either the name or age.

```python title="functions/users/update_user/main.py"
import json
from dataclasses import dataclass
import os
import boto3


@dataclass
class Path:
    user_id: str


@dataclass
class Input:
    name: str
    age: int


@dataclass
class Output:
    message: str

def lambda_handler(event, context):
    # Retrieve the DynamoDB table name from environment variables set in the Lambda configuration
    USERS_TABLE_NAME = os.environ.get("USERS_TABLE_NAME")

    # Initialize a DynamoDB resource using boto3, AWS's SDK for Python
    dynamodb = boto3.resource("dynamodb")

    # Reference the DynamoDB table using the retrieved table name
    users_table = dynamodb.Table(USERS_TABLE_NAME)

    # Extract the user ID from the pathParameters of the event object passed to the Lambda
    user_id = event["pathParameters"].get("user_id")

    # Parse the JSON body from the event object to get the user data
    body = json.loads(event["body"])

    # Update the specified user item in the DynamoDB table with the provided name and age
    users_table.put_item(Item={"PK": user_id, "name": body["name"], "age": body["age"]})

    # Return a response indicating successful user update, with a 200 HTTP status code
    return {
        "statusCode": 200,
        "body": json.dumps({"message": "User updated"}, default=str),
    }
```

### Configuration Class

Here's the configuration needed for the `update user` function to properly engage with the essential AWS services.

```python title="functions/users/update_user/config.py"
from infra.services import Services

class UpdateUserConfig:
  def __init__(self, services: Services) -> None:

    function = services.aws_lambda.create_function(
        name="UpdateUser",
        path="./functions/users",
        description="Update an User",
        directory="update_user",
        environment={
            "USERS_TABLE_NAME": services.dynamo_db.users_table.table_name,
        },
    )

    services.api_gateway.create_endpoint("PUT", "/users/{user_id}", function, public=True)

    services.dynamo_db.users_table.grant_write_data(function)
```

## Implementing the Delete Functionality

Now, to complete our CRUD application, let's proceed with constructing the Delete User endpoint.

```
forge function delete_user --method "DELETE" --description "Delete an user by ID" --belongs-to users --endpoint "/users/{user_id}" --public
```

Upon executing the Forge command, the `delete_user` folder will appear within the `infra/users` directory.

```
functions
└── users
    ├── create_user
    │   ├── __init__.py
    │   ├── config.py
    │   ├── integration.py
    │   ├── main.py
    │   └── unit.py
    ├── delete_user
    │   ├── __init__.py
    │   ├── config.py
    │   ├── integration.py
    │   ├── main.py
    │   └── unit.py
    ├── get_user
    │   ├── __init__.py
    │   ├── config.py
    │   ├── integration.py
    │   ├── main.py
    │   └── unit.py
    ├── update_user
    │   ├── __init__.py
    │   ├── config.py
    │   ├── integration.py
    │   ├── main.py
    │   └── unit.py
    └── utils
        └── __init__.py
```

### Core Logic

Below is the streamlined code for removing a user from DynamoDB using their user ID.

```python title="functions/users/delete_user/main.py"
import json
from dataclasses import dataclass
import os
import boto3

@dataclass
class Path:
    user_id: str

@dataclass
class Input:
    pass

@dataclass
class Output:
    message: str


def lambda_handler(event, context):
    # Fetch the name of the DynamoDB table from the environment variables.
    USERS_TABLE_NAME = os.environ.get("USERS_TABLE_NAME")

    # Initialize a DynamoDB resource using the boto3 library.
    dynamodb = boto3.resource("dynamodb")

    # Reference the DynamoDB table by its name.
    users_table = dynamodb.Table(USERS_TABLE_NAME)

    # Extract the user ID from the path parameters in the event object.
    user_id = event["pathParameters"].get("user_id")

    # Delete the item with the specified user ID from the DynamoDB table.
    users_table.delete_item(Key={"PK": user_id})

    # Return a response indicating that the user has been successfully deleted, with a 200 HTTP status code.
    return {"statusCode": 200, "body": json.dumps({"message": "User deleted"})}
```

### Configuration Class

Here's how to set up the `delete user` function for interaction with the required AWS resources.

```python title="functions/users/delete_user/config.py"
from infra.services import Services


class DeleteUserConfig:
    def __init__(self, services: Services) -> None:

        function = services.aws_lambda.create_function(
            name="DeleteUser",
            path="./functions/users",
            description="Delete an User",
            directory="delete_user",
            environment={
                "USERS_TABLE_NAME": services.dynamo_db.users_table.table_name,
            },
        )

        services.api_gateway.create_endpoint("DELETE", "/users/{user_id}", function, public=True)

        services.dynamo_db.users_table.grant_write_data(function)
```

## Deploying Our Serverless CRUD Application

Fantastic, with our four fundamental operations in place, we're ready for deployment to AWS.

```bash
# Send your changes to stage
git add .

# Commit with a descriptive message
git commit -m "Developing a CRUD with DynamoDB"

# Push changes to the 'dev' branch
git push origin dev

# Merge 'dev' into 'staging' and push
git checkout staging
git merge dev
git push origin staging

# Finally, merge 'staging' into 'main' and push
git checkout main
git merge staging
git push origin main
```

![Dev pipeline running](images/three_example_pipelines.png)

For simplicity, we'll focus on demonstrating the processes in the production stage. However, these operations can be similarly conducted using the base URLs for other environments.

```title="Prod - Create User"
curl --request POST \
  --url https://api.lambda-forge.com/users \
  --data '{
    "name": "John Doe",
    "age": 30
}'
```

```title="Prod - Get User"
curl --request GET \
  --url https://api.lambda-forge.com/users/$USER-ID
```

```title="Prod - Update User"
curl --request PUT \
  --url https://api.lambda-forge.com/users/$USER-ID \
  --data '{
	"name": "John Doe",
	"age": 31
}'
```

```title="Prod - Delete User"
curl --request DELETE \
  --url https://api.lambda-forge.com/users/$USER-ID
```

Congratulations! 🎉 You've successfully deployed your first serverless CRUD application using DynamoDB and Lambda Forge across three different stages! 🚀👩‍💻 --> --> -->
